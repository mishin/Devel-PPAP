#!/usr/bin/env perl

use strict;
use warnings;
use autodie;
use File::Spec;

my %OP_GROUP = (
    WANTARRAY => '',
    CONST => '',
    GVSV => '',
    GV => '',
    GELEM => '',
    PADSV => 'pad',
    PADAV => 'pad',
    PADHV => 'pad',
    PADANY => 'pad',
    PUSHRE => '',
    RV2GV => '',
    RV2SV => '',
    AV2ARYLEN => 'array',
    RV2CV => '',
    REFGEN => '',
    SREFGEN => '',
    REF => '',
    BLESS => '',
    BACKTICK => '',
    GLOB => '',
    READLINE => '',
    RCATLINE => '',
    QR => 'regexp',
    SUBST => 'string',
    SUBSTCONT => 'string',
    TRANS => '',
    SASSIGN => 'scalar',
    AASSIGN => 'array',
    CHOP => 'string',
    SCHOP => 'string',
    CHOMP => 'string',
    SCHOMP => 'string',
    DEFINED => '',
    UNDEF => '',
    STUDY => 'string',
    POS => 'string',
    PREINC => 'math',
    I_PREINC => 'math',
    PREDEC => 'math',
    I_PREDEC => 'math',
    POSTINC => 'math',
    I_POSTINC => 'math',
    POSTDEC => 'math',
    I_POSTDEC => 'math',
    POW => 'math',
    MULTIPLY => 'math',
    I_MULTIPLY => 'math',
    DIVIDE => 'math',
    I_DIVIDE => 'math',
    MODULO => 'math',
    I_MODULO => 'math',
    REPEAT => 'multi',
    ADD => 'math',
    I_ADD => 'math',
    SUBTRACT => 'math',
    I_SUBTRACT => 'math',
    CONCAT => 'string',
    STRINGIFY => 'string',
    LEFT_SHIFT => 'math',
    RIGHT_SHIFT => 'math',
    LT => 'logic',
    I_LT => 'logic',
    GT => 'logic',
    I_GT => 'logic',
    LE => 'logic',
    I_LE => 'logic',
    GE => 'logic',
    I_GE => 'logic',
    EQ => 'logic',
    I_EQ => 'logic',
    NE => 'logic',
    I_NE => 'logic',
    NCMP => 'logic',
    I_NCMP => 'logic',
    SLT => 'logic',
    SGT => 'logic',
    SLE => 'logic',
    SGE => 'logic',
    SEQ => 'logic',
    SNE => 'logic',
    SCMP => 'logic',
    BIT_AND => 'logic',
    BIT_XOR => 'logic',
    BIT_OR => 'logic',
    NEGATE => 'logic',
    I_NEGATE => 'logic',
    NOT => 'logic',
    COMPLEMENT => '',
    SMARTMATCH => '',
    ATAN2 => 'math',
    SIN => 'math',
    COS => 'math',
    RAND => 'math',
    SRAND => 'math',
    EXP => 'math',
    LOG => 'math',
    SQRT => 'math',
    INT => 'math',
    HEX => '',
    OCT => '',
    ABS => 'math',
    LENGTH => 'string',
    SUBSTR => 'string',
    VEC => '',
    INDEX => 'string',
    RINDEX => 'string',
    SPRINTF => 'string',
    FORMLINE => 'string',
    ORD => '',
    CHR => 'string',
    CRYPT => '',
    UCFIRST => 'string',
    LCFIRST => 'string',
    UC => 'string',
    LC => 'string',
    QUOTEMETA => '',
    RV2AV => '',
    AELEMFAST => 'array',
    AELEM => 'array',
    ASLICE => 'array',
    AEACH => 'array',
    AKEYS => 'array',
    AVALUES => 'array',
    EACH => 'hash',
    VALUES => 'hash',
    KEYS => 'hash',
    DELETE => '?',
    EXISTS => '?',
    RV2HV => '',
    HELEM => 'hash',
    HSLICE => 'hash',
    BOOLKEYS => 'hash',
    UNPACK => '',
    PACK => '',
    SPLIT => 'string',
    JOIN => 'string',
    LIST => '',
    LSLICE => '',
    ANONLIST => '',
    ANONHASH => '',
    SPLICE => 'array',
    PUSH => 'array',
    POP => 'array',
    SHIFT => 'array',
    UNSHIFT => 'array',
    SORT => '',
    REVERSE => '',
    GREPSTART => '',
    GREPWHILE => '',
    MAPSTART => '',
    MAPWHILE => '',
    RANGE => '',
    FLIP => '',
    FLOP => '',
    AND => 'logic',
    OR => 'logic',
    XOR => 'logic',
    DOR => 'logic',
    COND_EXPR => 'logic',
    ANDASSIGN => '',
    ORASSIGN => '',
    DORASSIGN => '',
    METHOD => 'class',
    ENTERSUB => 'sub',
    LEAVESUB => 'sub',
    LEAVESUBLV => 'sub',
    CALLER => '',
    WARN => '',
    DIE => '',
    RESET => '',
    LINESEQ => '',
    NEXTSTATE => '',
    DBSTATE => '',
    UNSTACK => '',
    ENTER => '',
    LEAVE => '',
    SCOPE => '',
    ENTERITER => '',
    ITER => '',
    ENTERLOOP => '',
    LEAVELOOP => '',
    RETURN => '',
    LAST => '',
    NEXT => '',
    REDO => '',
    DUMP => '',
    GOTO => '',
    EXIT => '',
    METHOD_NAMED => 'class',
    ENTERGIVEN => '',
    LEAVEGIVEN => '',
    ENTERWHEN => '',
    LEAVEWHEN => '',
    BREAK => '',
    CONTINUE => '',
    OPEN => 'IO',
    CLOSE => 'IO',
    PIPE_OP => '',
    FILENO => 'IO',
    UMASK => '',
    BINMODE => 'IO',
    TIE => '',
    UNTIE => '',
    TIED => '',
    SSELECT => '',
    SELECT => '',
    GETC => 'IO',
    READ => 'IO',
    ENTERWRITE => '',
    LEAVEWRITE => '',
    PRTF => 'IO',
    PRINT => 'IO',
    SAY => 'IO',
    SYSOPEN => 'IO',
    SYSSEEK => 'IO',
    SYSREAD => 'IO',
    SYSWRITE => 'IO',
    EOF => 'IO',
    TELL => '',
    SEEK => 'IO',
    TRUNCATE => 'IO',
    FCNTL => 'IO',
    IOCTL => 'IO',
    FLOCK => '',
    SEND => '',
    RECV => '',
    SOCKET => '',
    SOCKPAIR => '',
    BIND => '',
    CONNECT => '',
    LISTEN => '',
    ACCEPT => '',
    SHUTDOWN => '',
    GSOCKOPT => '',
    SSOCKOPT => '',
    GETSOCKNAME => '',
    GETPEERNAME => '',
    LSTAT => 'FS',
    STAT => 'FS',
    CHDIR => 'FS',
    CHOWN => 'FS',
    CHROOT => '',
    UNLINK => 'FS',
    CHMOD => 'FS',
    UTIME => '',
    RENAME => 'FS',
    LINK => 'FS',
    SYMLINK => 'FS',
    READLINK => 'FS',
    MKDIR => 'FS',
    RMDIR => 'FS',
    OPEN_DIR => 'FS',
    READDIR => 'FS',
    TELLDIR => 'FS',
    SEEKDIR => 'FS',
    REWINDDIR => 'FS',
    CLOSEDIR => 'FS',
    FORK => 'system',
    WAIT => 'system',
    WAITPID => 'system',
    SYSTEM => 'system',
    EXEC => 'system',
    KILL => 'system',
    GETPPID => 'system',
    GETPGRP => 'system',
    SETPGRP => 'system',
    GETPRIORITY => 'system',
    SETPRIORITY => 'system',
    TIME => 'time',
    TMS => 'time',
    LOCALTIME => 'time',
    GMTIME => 'time',
    ALARM => 'time',
    SLEEP => 'time',
    SHMGET => '',
    SHMCTL => '',
    SHMREAD => '',
    SHMWRITE => '',
    MSGGET => '',
    MSGCTL => '',
    MSGSND => '',
    MSGRCV => '',
    SEMOP => '',
    SEMGET => '',
    SEMCTL => '',
    REQUIRE => '',
    DOFILE => '',
    HINTSEVAL => '',
    ENTEREVAL => '',
    LEAVEEVAL => '',
    ENTERTRY => '',
    LEAVETRY => '',
    GHBYNAME => '',
    GHBYADDR => '',
    GHOSTENT => '',
    GNBYNAME => '',
    GNBYADDR => '',
    GNETENT => '',
    GPBYNAME => '',
    GPBYNUMBER => '',
    GPROTOENT => '',
    GSBYNAME => '',
    GSBYPORT => '',
    GSERVENT => '',
    SHOSTENT => '',
    SNETENT => '',
    SPROTOENT => '',
    SSERVENT => '',
    EHOSTENT => '',
    ENETENT => '',
    EPROTOENT => '',
    ESERVENT => '',
    GPWNAM => '',
    GPWUID => '',
    GPWENT => '',
    SPWENT => '',
    EPWENT => '',
    GGRNAM => '',
    GGRGID => '',
    GGRENT => '',
    SGRENT => '',
    EGRENT => '',
    GETLOGIN => '',
    SYSCALL => '',
    LOCK => '',
    ONCE => '',
    CUSTOM => '',
);

my %results = (
);

walk_report( sub {
    my ($ctx,$lval,$op,$args, $time) = @_;
    $results{'ops'}{$op}++;
    $results{'time'}{$op} += $time;
    $results{'context'}{$op}{$ctx}++;
    $results{'lvalue'}{$op}++ if $lval;
} );

prepare_report_dir();

report();
exit 0;

sub report {
    my $fh = new_file('index.html');
    out_head($fh, 'PP op codes access patterns');
    out_groupped_usage($fh, \%results);
    out_pp_usage($fh, \%results);
    out_context($fh, $results{'context'});
    out_variable_arguments($fh);
    out_arrays_arguments($fh);
    out_footer($fh);
    close $fh;

    pp_reports();
}

sub pp_reports {

}

sub walk_report {
    my $cb = shift;
    open my $fh, '<:utf8', 'ppap.out';
    while ( my $str = <$fh> ) {
        chomp($str);
        unless ( $str =~ /^([-\$\@?])(=?)\s(\w+)\s*(.*)\s+\|([0-9]+)$/ ) {
            warn "String '$str' is not parsable";
            next;
        }

        $cb->($1, $2, $3, $4, $5);
    }
    close $fh;
}

sub out_groupped_usage {
    my ($out, $results) = (@_);
    my $total = 0;
    my %grps = ();
    while ( my ($op, $count) = each %{ $results->{'ops'} } ) {
        $grps{ $OP_GROUP{uc $op} || 'other' } += $count;
        $total += $count;
    }

    render_table(
        $out,
        title => 'Groupped PPs usage',
        elements => [ sort keys %grps ],
        columns  => [qw(Group count %)],
        type     => [qw(string counter percent)],
        callback => sub {
            my $group = shift;
            return [$group, $grps{$group}, (100*$grps{$group})/$total];
        }
    );
}

sub out_pp_usage {
    my ($out, $results) = (@_);
    my $total = 0;
    $total += $_ foreach values %{ $results->{'ops'} };
    my $ttime = 0;
    $ttime += $_ foreach values %{ $results->{'time'} };

    render_table(
        $out,
        title => 'PPs usage',
        elements => [ sort keys %{ $results->{'ops'} } ],
        columns  => [qw(PP group count % time % mean ratio)],
        type     => [qw(string string counter percent time percent num num)],
        callback => sub {
            my $op = shift;
            my $count_perc = (100*$results->{'ops'}{$op})/$total;
            my $time_perc = (100*$results->{'time'}{$op})/$ttime;
            return [
                $op, $OP_GROUP{uc $op} || 'other',
                $results->{'ops'}{$op}, $count_perc,
                $results->{'time'}{$op}, $time_perc,
                $results->{'time'}{$op}/$results->{'ops'}{$op},
                ($time_perc/$count_perc),
            ];
        },
    );
}

sub render_table {
    my $out = shift;
    my %args = @_;

    my $res = '';
    if ( $args{'title'} ) {
        $res .= "<h1>$args{'title'}</h1>\n";
    }
    $res .= '<table class="sortable">'. "\n";
    $res .= "<thead><tr>". join('', map "<th>$_</th>", @{ $args{'columns'} }) ."</tr></thead>\n";

    foreach my $e ( @{ $args{'elements'} } ) {
        $e = $args{'callback'}->( $e );
    }

    if ( $args{'sort'} ) {
        # ...
    }

    $res .= "<tbody>\n";
    foreach my $row ( @{ $args{'elements'} } ) {
        $res .= "<tr>". join('', map "<td>$_</td>", @$row) ."</tr>\n"
    }
    $res .= "</tbody>\n";

    $res .= "</table>\n\n";

    print $out $res;
}

sub out_context {
    my ($out, $results) = (@_);
    my %total = ();

    my $res = '';

    $res .= "<h1>Context</h1>\n";
    $res .= "<table>\n<tr><th>&nbsp;</th><th>void</th><th>scalar</th><th>array</th></tr>\n";

    foreach my $op ( sort { $a cmp $b } keys %$results ) {
        my $total = 0;
        $total += $_ foreach values %{ $results->{$op} };
        $total{$_} += $results->{$op}{$_} || 0 foreach qw(- $ @);
        
        $res .= "<tr><th>$op</th>";
        foreach my $ctx ( qw(- $ @) ) {
            my $value = $results->{$op}{$ctx};
            $res .= $value
                ? sprintf("<td>%d<sup>%0.2f%%</sup></td>", $value, (100*$value)/$total )
                : "<td>-</td>"
            ;
        }
        $res .= "</tr>\n";
    }

    my $total = 0;
    $total += $_ foreach values %total;
    $res .= "<tr><th>Total:</th>";
    foreach my $ctx ( qw(- $ @) ) {
        $res .= $total{$ctx}
            ? sprintf(
                "<td>%d<sup>%0.2f%%</sup></td>",
                $total{$ctx}, (100*$total{$ctx})/$total
            )
            : "<td>-</td>"
        ;
    }
    $res .= "</tr>\n";
    $res .= "</table>\n";

    print $out $res;
}

sub out_variable_arguments {
    my $out = shift;

    my %stats;
    my %total_per_op;
    my %total_per_len;

    print $out "<h1>Varying arguments</h1>\n";
    walk_report( sub {
        my ($ctx,$lval,$op,$args) = @_;
        return unless rindex($args, '...') >= 0;
        my ($l) = ($args =~ /\.\.\.([0-9]+)/);
        $stats{$op}{$l}++;
        $total_per_len{$l}++;
        $total_per_op{$op}++;
    } );

    my $show_first = 5;

    my $res = '';
    $res .= "<h2>Most used lengths</h2>\n";
    $res .= "<table>\n<tr><th>PP</th>". join( '', map "<th>$_</th>", 1 .. $show_first ) ."</tr>\n";
    foreach my $op ( sort keys %stats ) {
        $res .= "<tr><th>$op</th>";
        my $found = 0;
        foreach my $len (
            sort { $stats{$op}{$b} <=> $stats{$op}{$a} }
            keys %{ $stats{$op} }
        ) {
            $found++;

            $res .= sprintf
                "<td>%d <sup>%0.2f%%</sup></td>",
                $len, (100*$stats{$op}{$len})/$total_per_op{$op},
            ;

            last if $found == $show_first;
        }
        $res .= join '', map "<td>-</td>", 1 .. $show_first-$found
            if $found < $show_first;
        $res .= "</tr>\n";
    }
    {
        my $total = 0;
        $total += $_ foreach values %total_per_len;

        $res .= "<tr><th>Total:</th>";
        my $found = 0;
        foreach my $len (
            sort { $total_per_len{$b} <=> $total_per_len{$a} }
            keys %total_per_len
        ) {
            $found++;

            $res .= sprintf
                "<td>%d <sup>%0.2f%%</sup></td>",
                $len, (100*$total_per_len{$len})/$total,
            ;

            last if $found == $show_first;
        }
        $res .= join '', map "<td>-</td>", 1 .. $show_first-$found
            if $found < $show_first;
        $res .= "</tr>\n";

    }
    $res .= "</table>\n";
    print $out $res;
    $res = '';

    
    my @fractiles = fractiles();
    $res .= "<h2>Fractiles</h2>\n";
    $res .= "<table>\n<tr><th>PP</th>". join( '', map "<th>$_%</th>", @fractiles ) ."</tr>\n";
    foreach my $op ( sort keys %stats ) {
        my $fractiles = calc_fractiles( $stats{$op}, $total_per_op{$op} );
        $res .= "<tr><th>$op</th>";
        foreach my $f ( @fractiles ) {
            $res .= exists $fractiles->{ $f }
                ? sprintf("<td>%0d</td>", $fractiles->{ $f })
                : "<td>-</td>"
            ;
        }
        $res .= "</tr>\n";
    }
    $res .= "</table>\n";
    print $out $res;
    $res = '';
}

sub out_arrays_arguments {
    my $out = shift;

    my %stats;
    my %total_per_len;

    print $out "<h1>Array arguments</h1>\n";

    walk_report( sub {
        my ($ctx,$lval,$op,$args) = @_;
        return unless rindex($args, '@') >= 0;
        my ($prefix, $length, $sufix) = ($args =~ /@\_?\([^\)]+\)([0-9]+)-([0-9]+)-([0-9]+)/);
        next unless defined $prefix;
        $stats{$op}{'prefix'}{$prefix}++;
        $stats{$op}{'length'}{$length}++;
        $stats{$op}{'sufix'}{$sufix}++;
        $total_per_len{'prefix'}{$prefix}++;
        $total_per_len{'length'}{$length}++;
        $total_per_len{'sufix'}{$sufix}++;
    } );

    my $res = '';

    my @fractiles = fractiles();
    $res .= "<h2>Fractiles</h2>\n";
    $res .= "<table>\n<tr><th>PP</th><th></th>". join( '', map "<th>$_%</th>", @fractiles ) ."</tr>\n";
    foreach my $op ( sort keys %stats ) {
        $res .= "<tr><th rowspan='3'>$op</th>";
        foreach my $e ( qw(prefix length sufix) ) {
            $res .= "<tr>" if $e ne 'prefix';
            my $fractiles = calc_fractiles( $stats{$op}{$e} );
            $res .= "<th>$e</th>";
            foreach my $f ( @fractiles ) {
                $res .= exists $fractiles->{ $f }
                    ? sprintf("<td>%0d</td>", $fractiles->{ $f })
                    : "<td>-</td>"
                ;
            }
            $res .= "</tr>\n";
        }
    }
    $res .= "</table>\n";
    print $out $res;
    $res = '';
}

sub fractiles {
    return (100, 99, 98, 97, 96, 95, 90, 80, 70, 60, 50, 30, 10);
}

sub max(@) {
    my $res = 0;
    $res < $_ and $res = $_
        foreach @_;
    return $res;
}

sub calc_fractiles {
    my $data = shift;
    my $total = shift || 0;
    unless ( $total ) {
        $total += $_ foreach values %$data;
    }

    my %copy = %$data;
    use Data::Dumper;

    my @fractiles = fractiles();

    my %res;

    my $sum = 100; my $max = max keys %copy;
    foreach my $v ( sort { $copy{$a} <=> $copy{$b} } keys %copy ) {
        my $portion = (100*$copy{ $v })/$total;
        if ( ($sum - $portion) < $fractiles[0] ) {
            while ( @fractiles && $sum <= $fractiles[0] ) {
                $res{ shift @fractiles } = $max;
            }
            last unless @fractiles;
        }
        $sum -= $portion;
        delete $copy{ $v };
        $max = max keys %copy
            if $max == $v;
    }

    return \%res;
}

sub out_head {
    my $out = shift;
    my $title = shift;
    print $out '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"'
        .' "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">', "\n";
    print $out "<html>\n<head>\n";
    print $out "<title>$title</title>\n";
    print $out '<link rel="stylesheet" href="css/main.css" type="text/css" media="all" />', "\n";
    print $out '<script type="text/javascript" src="js/jquery-1.4.2.min.js"></script>', "\n";
    print $out '<script type="text/javascript" src="js/jquery.tablesorter.min.js"></script>', "\n";
    print $out '<script type="text/javascript" src="js/ppap.js"></script>', "\n";
    print $out "</head>\n<body>\n";
}

sub out_footer {
    my $out = shift;
    print $out "</body></html>\n";
}

sub prepare_report_dir {
    use File::ShareDir qw(dist_dir);
    use File::Path qw(make_path);
    use File::Copy qw(copy);

    foreach my $n (qw(css js)) {
        my $src = File::Spec->catfile( dist_dir('Devel-PPAP'), $n, '*' );
        print "$src\n";
        my $dst = File::Spec->catdir('ppap', $n);
        make_path( $dst, {} );
        copy($_, $dst) foreach glob $src;
    }
}

sub new_file {
    my $name = shift;
    open my $fh, '>:utf8', File::Spec->catfile('ppap', $name );
    return $fh;
}

