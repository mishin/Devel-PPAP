#!/usr/bin/env perl

use strict;
use warnings;
use autodie;

use File::Spec;
use File::ShareDir qw(dist_dir);
use File::Path qw(make_path);
use File::Copy qw(copy);

my %OP_GROUP = (
    WANTARRAY => '',
    CONST => '',
    GVSV => '',
    GV => '',
    GELEM => '',
    PADSV => 'pad',
    PADAV => 'pad',
    PADHV => 'pad',
    PADANY => 'pad',
    PUSHRE => '',
    RV2GV => '',
    RV2SV => '',
    AV2ARYLEN => 'array',
    RV2CV => '',
    REFGEN => '',
    SREFGEN => '',
    REF => '',
    BLESS => '',
    BACKTICK => '',
    GLOB => '',
    READLINE => '',
    RCATLINE => '',
    QR => 'regexp',
    SUBST => 'regexp',
    SUBSTCONT => 'regexp',
    TRANS => 'string',
    SASSIGN => 'scalar',
    AASSIGN => 'array',
    CHOP => 'string',
    SCHOP => 'string',
    CHOMP => 'string',
    SCHOMP => 'string',
    DEFINED => 'logic',
    UNDEF => '',
    STUDY => 'string',
    POS => 'string',
    PREINC => 'math',
    I_PREINC => 'math',
    PREDEC => 'math',
    I_PREDEC => 'math',
    POSTINC => 'math',
    I_POSTINC => 'math',
    POSTDEC => 'math',
    I_POSTDEC => 'math',
    POW => 'math',
    MULTIPLY => 'math',
    I_MULTIPLY => 'math',
    DIVIDE => 'math',
    I_DIVIDE => 'math',
    MODULO => 'math',
    I_MODULO => 'math',
    REPEAT => 'multi',
    ADD => 'math',
    I_ADD => 'math',
    SUBTRACT => 'math',
    I_SUBTRACT => 'math',
    CONCAT => 'string',
    STRINGIFY => 'string',
    LEFT_SHIFT => 'math',
    RIGHT_SHIFT => 'math',
    LT => 'logic',
    I_LT => 'logic',
    GT => 'logic',
    I_GT => 'logic',
    LE => 'logic',
    I_LE => 'logic',
    GE => 'logic',
    I_GE => 'logic',
    EQ => 'logic',
    I_EQ => 'logic',
    NE => 'logic',
    I_NE => 'logic',
    NCMP => 'logic',
    I_NCMP => 'logic',
    SLT => 'logic',
    SGT => 'logic',
    SLE => 'logic',
    SGE => 'logic',
    SEQ => 'logic',
    SNE => 'logic',
    SCMP => 'logic',
    BIT_AND => 'logic',
    BIT_XOR => 'logic',
    BIT_OR => 'logic',
    NEGATE => 'logic',
    I_NEGATE => 'logic',
    NOT => 'logic',
    COMPLEMENT => '',
    SMARTMATCH => '',
    ATAN2 => 'math',
    SIN => 'math',
    COS => 'math',
    RAND => 'math',
    SRAND => 'math',
    EXP => 'math',
    LOG => 'math',
    SQRT => 'math',
    INT => 'math',
    HEX => '',
    OCT => '',
    ABS => 'math',
    LENGTH => 'string',
    SUBSTR => 'string',
    VEC => '',
    INDEX => 'string',
    RINDEX => 'string',
    SPRINTF => 'string',
    FORMLINE => 'string',
    ORD => '',
    CHR => 'string',
    CRYPT => '',
    UCFIRST => 'string',
    LCFIRST => 'string',
    UC => 'string',
    LC => 'string',
    QUOTEMETA => '',
    RV2AV => '',
    AELEMFAST => 'array',
    AELEM => 'array',
    ASLICE => 'array',
    AEACH => 'array',
    AKEYS => 'array',
    AVALUES => 'array',
    EACH => 'hash',
    VALUES => 'hash',
    KEYS => 'hash',
    DELETE => '?',
    EXISTS => '?',
    RV2HV => '',
    HELEM => 'hash',
    HSLICE => 'hash',
    BOOLKEYS => 'hash',
    UNPACK => '',
    PACK => '',
    SPLIT => 'string',
    JOIN => 'string',
    LIST => '',
    LSLICE => '',
    ANONLIST => '',
    ANONHASH => '',
    SPLICE => 'array',
    PUSH => 'array',
    POP => 'array',
    SHIFT => 'array',
    UNSHIFT => 'array',
    SORT => '',
    REVERSE => '',
    GREPSTART => '',
    GREPWHILE => '',
    MAPSTART => '',
    MAPWHILE => '',
    RANGE => '',
    FLIP => '',
    FLOP => '',
    AND => 'logic',
    OR => 'logic',
    XOR => 'logic',
    DOR => 'logic',
    COND_EXPR => 'logic',
    ANDASSIGN => '',
    ORASSIGN => '',
    DORASSIGN => '',
    METHOD => 'class',
    ENTERSUB => 'sub',
    LEAVESUB => 'sub',
    LEAVESUBLV => 'sub',
    CALLER => '',
    WARN => '',
    DIE => '',
    RESET => '',
    LINESEQ => '',
    NEXTSTATE => '',
    DBSTATE => '',
    UNSTACK => '',
    ENTER => '',
    LEAVE => '',
    SCOPE => '',
    ENTERITER => '',
    ITER => '',
    ENTERLOOP => '',
    LEAVELOOP => '',
    RETURN => '',
    LAST => '',
    NEXT => '',
    REDO => '',
    DUMP => '',
    GOTO => '',
    EXIT => '',
    METHOD_NAMED => 'class',
    ENTERGIVEN => '',
    LEAVEGIVEN => '',
    ENTERWHEN => '',
    LEAVEWHEN => '',
    BREAK => '',
    CONTINUE => '',
    OPEN => 'IO',
    CLOSE => 'IO',
    PIPE_OP => '',
    FILENO => 'IO',
    UMASK => '',
    BINMODE => 'IO',
    TIE => '',
    UNTIE => '',
    TIED => '',
    SSELECT => '',
    SELECT => '',
    GETC => 'IO',
    READ => 'IO',
    ENTERWRITE => '',
    LEAVEWRITE => '',
    PRTF => 'IO',
    PRINT => 'IO',
    SAY => 'IO',
    SYSOPEN => 'IO',
    SYSSEEK => 'IO',
    SYSREAD => 'IO',
    SYSWRITE => 'IO',
    EOF => 'IO',
    TELL => '',
    SEEK => 'IO',
    TRUNCATE => 'IO',
    FCNTL => 'IO',
    IOCTL => 'IO',
    FLOCK => '',
    SEND => '',
    RECV => '',
    SOCKET => '',
    SOCKPAIR => '',
    BIND => '',
    CONNECT => '',
    LISTEN => '',
    ACCEPT => '',
    SHUTDOWN => '',
    GSOCKOPT => '',
    SSOCKOPT => '',
    GETSOCKNAME => '',
    GETPEERNAME => '',
    LSTAT => 'FS',
    STAT => 'FS',
    CHDIR => 'FS',
    CHOWN => 'FS',
    CHROOT => '',
    UNLINK => 'FS',
    CHMOD => 'FS',
    UTIME => '',
    RENAME => 'FS',
    LINK => 'FS',
    SYMLINK => 'FS',
    READLINK => 'FS',
    MKDIR => 'FS',
    RMDIR => 'FS',
    OPEN_DIR => 'FS',
    READDIR => 'FS',
    TELLDIR => 'FS',
    SEEKDIR => 'FS',
    REWINDDIR => 'FS',
    CLOSEDIR => 'FS',
    FORK => 'system',
    WAIT => 'system',
    WAITPID => 'system',
    SYSTEM => 'system',
    EXEC => 'system',
    KILL => 'system',
    GETPPID => 'system',
    GETPGRP => 'system',
    SETPGRP => 'system',
    GETPRIORITY => 'system',
    SETPRIORITY => 'system',
    TIME => 'time',
    TMS => 'time',
    LOCALTIME => 'time',
    GMTIME => 'time',
    ALARM => 'time',
    SLEEP => 'time',
    SHMGET => '',
    SHMCTL => '',
    SHMREAD => '',
    SHMWRITE => '',
    MSGGET => '',
    MSGCTL => '',
    MSGSND => '',
    MSGRCV => '',
    SEMOP => '',
    SEMGET => '',
    SEMCTL => '',
    REQUIRE => '',
    DOFILE => '',
    HINTSEVAL => '',
    ENTEREVAL => '',
    LEAVEEVAL => '',
    ENTERTRY => '',
    LEAVETRY => '',
    GHBYNAME => '',
    GHBYADDR => '',
    GHOSTENT => '',
    GNBYNAME => '',
    GNBYADDR => '',
    GNETENT => '',
    GPBYNAME => '',
    GPBYNUMBER => '',
    GPROTOENT => '',
    GSBYNAME => '',
    GSBYPORT => '',
    GSERVENT => '',
    SHOSTENT => '',
    SNETENT => '',
    SPROTOENT => '',
    SSERVENT => '',
    EHOSTENT => '',
    ENETENT => '',
    EPROTOENT => '',
    ESERVENT => '',
    GPWNAM => '',
    GPWUID => '',
    GPWENT => '',
    SPWENT => '',
    EPWENT => '',
    GGRNAM => '',
    GGRGID => '',
    GGRENT => '',
    SGRENT => '',
    EGRENT => '',
    GETLOGIN => '',
    SYSCALL => '',
    LOCK => '',
    ONCE => '',
    CUSTOM => '',
);

my %results = (
);

# PP reporters hash
my %PP_REPORTER_FOR = (
    push   => \&out_pp_push_usage,
    substr => \&out_pp_substr_usage,
);


walk_report( sub {
    my ($ctx,$lval,$op,$args,$time) = @_;
    $results{'ops'}{$op}++;
    $results{'time'}{$op} += $time;
} );

prepare_report_dir();

report();
exit 0;

# Вывести отчёт в html-файл
sub report {
    my $fh = new_file('index.html');
    out_head($fh, 'PP op codes access patterns');
    out_groupped_usage($fh, \%results);
    out_pp_usage($fh, \%results);
#    out_variable_arguments($fh);
#    out_arrays_arguments($fh);
    out_footer($fh);
    close $fh;

    pp_report($_) for qw( or push shift substr ); # sort keys %{ $results{'ops'} }
}

# Generate report for specific operator
sub pp_report {
    my $op = shift;

    # Find specific 'reporter' function or use default one
    my $reporter = $PP_REPORTER_FOR{$op} || \&out_pp_generic_usage;

    my $fh = new_file('pp', "$op.html");
    out_head($fh, "$op specific usage stats", '../');
    $reporter->($fh, $op);
    out_footer($fh);
    close $fh;
}

# Обработать отчёт ppap.out
# $cb - callback, которому передаются параметры отпарсенной строки
sub walk_report {
    my $cb = shift;
    open my $fh, '<:utf8', 'ppap.out';
    while ( my $str = <$fh> ) {
        chomp($str);
        my ($ctx,$lval,$rop,$args,$time) = $str =~ /^ 
            ([-\$\@?])      # контекст ('-' - void, '$' - scalar, '@' - array, '?' - хз)
            (=?)    \s+     # lvalue ли это
            (\w+)   \s*     # имя оператора
            (.*?)   \s*     # аргументы (требует доп. парсинга)
            \|([0-9]+)      # время выполнения, отделенное знаком |
        $/x;

        unless ( $ctx ) {
            warn "String '$str' is not parsable";
            next;
        }

        $cb->($ctx, $lval, $rop, $args, $time);
    }
    close $fh;
}

sub out_groupped_usage {
    my ($out, $results) = (@_);

    my ($tcount, $ttime) = (0, 0);

    my %grps = ();
    while ( my ($op, $count) = each %{ $results->{'ops'} } ) {
        $grps{ $OP_GROUP{uc $op} || 'other' }{'count'} += $count;
        $tcount += $count;

        $grps{ $OP_GROUP{uc $op} || 'other' }{'time'} += $results->{'time'}{$op};
        $ttime += $results->{'time'}{$op}
    }

    render_table(
        $out,
        title => 'Groupped PPs usage',
        elements => [ sort keys %grps ],
        columns  => [qw(Group count % time %)],
        type     => [qw(string counter percent time percent)],
        callback => sub {
            my $group = shift;
            return [
                $group, 
                $grps{$group}{'count'}, (100*$grps{$group}{'count'})/$tcount,
                $grps{$group}{'time'}, (100*$grps{$group}{'time'})/$ttime,
            ];
        }
    );
}

sub out_pp_generic_usage {
    my ($out, $op) = (@_);
    out_pp_context($out, $op);
}

sub out_pp_push_usage {
    my ($op, $out) = ('push', @_);
    out_pp_context($out, $op);
    out_variable_arg_size($out, $op);
    out_array_sufix_size($out, $op);
}

sub out_pp_substr_usage {
    my ($op, $out) = ('substr', @_);
    out_pp_context($out, $op);
    out_substr_arg_count($out, $op);
}

sub out_pp_usage {
    my ($out, $results) = (@_);
    my $total = 0;
    $total += $_ foreach values %{ $results->{'ops'} };
    my $ttime = 0;
    $ttime += $_ foreach values %{ $results->{'time'} };

    render_table(
        $out,
        title => 'PPs usage',
        elements => [ sort keys %{ $results->{'ops'} } ],
        columns  => [qw(PP group count % time % mean ratio)],
        type     => [qw(string string counter percent time percent num num)],
        callback => sub {
            my $op = shift;
            my $count_perc = (100*$results->{'ops'}{$op})/$total;
            my $time_perc = (100*$results->{'time'}{$op})/$ttime;
            return [
                "<a href='pp/$op.html'>$op</a>", $OP_GROUP{uc $op} || 'other',
                $results->{'ops'}{$op}, $count_perc,
                $results->{'time'}{$op}, $time_perc,
                $results->{'time'}{$op}/$results->{'ops'}{$op},
                ($time_perc/$count_perc),
            ];
        },
    );
}

sub out_pp_context {
    my $out = shift;
    my $op = shift;

    my %stats  = ();
    walk_report( sub {
        my ($ctx,$lval,$rop,$args,$time) = @_;
        return unless $rop eq $op;

        $stats{'counter'}{$ctx}++;
        $stats{'time'}{$ctx} += $time;
    } );

    render_table(
        $out,
        title => 'Context',
        elements => [ sort keys %{ $stats{'counter'} } ],
        columns  => [qw(context count % time % mean ratio)],
        type     => [qw(string counter percent time percent num num)],
        callback => sub {
            my $ctx = shift;
            my $count_perc = (100*$stats{'counter'}{$ctx})/$results{'ops'}{$op};
            my $time_perc = (100*$stats{'time'}{$ctx})/$results{'time'}{$op};
            return [
                $ctx,
                $stats{'counter'}{$ctx}, $count_perc,
                $stats{'time'}{$ctx}, $time_perc,
                $stats{'time'}{$ctx}/$stats{'counter'}{$ctx},
                ($time_perc/$count_perc),
            ];
        },
    );
}

sub out_substr_arg_count {
    my $out = shift;
    my $op = shift;

    my %stats  = ();
    walk_report( sub {
        my ($ctx,$lval,$rop,$args,$time) = @_;
        return unless $rop eq $op;
		my @temp_args = split(/, /, $args);
		my $args_count = @temp_args;

        my $type = undef;
        if ( $args_count == 2 ) {
		    $type = 'substr EXPR,OFFSET';
        } elsif ( $args_count == 3 ) {
		    $type = 'substr EXPR,OFFSET,LENGTH';
        } elsif ( $args_count == 4 ) {
		    $type = 'substr EXPR,OFFSET,LENGTH,REPLACEMENT';
		} else {
		    $type = 'Am I error?';
		}
        $stats{'counter'}{$type}++;
        $stats{'time'}{$type} += $time;
    } );

    render_table(
        $out,
        title => 'Substr argument count',
        elements => [ sort keys %{ $stats{'counter'} } ],
        columns  => [qw(type count % time % mean ratio)],
        type     => [qw(string counter percent time percent num num)],
        callback => sub {
            my $ctx = shift;
            my $count_perc = (100*$stats{'counter'}{$ctx})/$results{'ops'}{$op};
            my $time_perc = (100*$stats{'time'}{$ctx})/$results{'time'}{$op};
            return [
                $ctx,
                $stats{'counter'}{$ctx}, $count_perc,
                $stats{'time'}{$ctx}, $time_perc,
                $stats{'time'}{$ctx}/$stats{'counter'}{$ctx},
                ($time_perc/$count_perc),
            ];
        },
    );

}

sub out_variable_arg_size {
    my $out = shift;
    my $op = shift;

    my %stats  = ();
    walk_report( sub {
        my ($ctx,$lval,$rop,$args,$time) = @_;
        return unless $rop eq $op;
        return unless $args =~ /\.\.\.([0-9]+)$/;

        $stats{'counter'}{$1}++;
        $stats{'time'}{$1} += $time;
    } );

    render_table(
        $out,
        title => 'Variable argument size',
        elements => [ sort keys %{ $stats{'counter'} } ],
        columns  => [qw(size count % time % mean mean/elements ratio)],
        type     => [qw(counter counter percent time percent num num num)],
        callback => sub {
            my $ctx = shift;
            my $count_perc = (100*$stats{'counter'}{$ctx})/$results{'ops'}{$op};
            my $time_perc = (100*$stats{'time'}{$ctx})/$results{'time'}{$op};
            return [
                $ctx,
                $stats{'counter'}{$ctx}, $count_perc,
                $stats{'time'}{$ctx}, $time_perc,
                $stats{'time'}{$ctx}/$stats{'counter'}{$ctx},
                $ctx? $stats{'time'}{$ctx}/$stats{'counter'}{$ctx}/$ctx : 0.0,
                ($time_perc/$count_perc),
            ];
        },
    );
}

sub out_array_sufix_size {
    my $out = shift;
    my $op = shift;

    my %stats  = ();
    walk_report( sub {
        my ($ctx,$lval,$rop,$args,$time) = @_;
        return unless $rop eq $op;
        return unless $args =~ /\.\.\.([0-9]+)$/;
        my $list_size = $1;

        return unless $args =~ /([0-9]+)-([0-9]+)-([0-9]+)/;
        my ($prefix, $array_size, $sufix) = ($1, $2, $3);

        my $type = undef;
        unless ( $list_size ) {
            $type = 'no argument';
        } elsif ( !$prefix && !$array_size && !$sufix ) {
            $type = 'empty array';
        } elsif ( $sufix >= $list_size ) {
            $type = 'sufix fits';
        } elsif ( ($sufix+$prefix) >= $list_size ) {
            $type = 'prefix+sufix fits';
        } else {
            $type = 'no space';
        }
        $stats{'counter'}{$type}++;
        $stats{'time'}{$type} += $time;
        $stats{'size'}{$type} += $list_size;
    } );

    render_table(
        $out,
        title => 'Suffix size',
        elements => [ sort keys %{ $stats{'counter'} } ],
        columns  => [qw(status count % time % mean mean/elements ratio)],
        type     => [qw(string counter percent time percent num num num)],
        callback => sub {
            my $ctx = shift;
            my $count_perc = (100*$stats{'counter'}{$ctx})/$results{'ops'}{$op};
            my $time_perc = (100*$stats{'time'}{$ctx})/$results{'time'}{$op};
            return [
                $ctx,
                $stats{'counter'}{$ctx}, $count_perc,
                $stats{'time'}{$ctx}, $time_perc,
                $stats{'time'}{$ctx}/$stats{'counter'}{$ctx},
                $stats{'size'}{$ctx}? $stats{'time'}{$ctx}/$stats{'counter'}{$ctx}/$stats{'size'}{$ctx} : 0.0,
                ($time_perc/$count_perc),
            ];
        },
    );
}

sub render_table {
    my $out = shift;
    my %args = @_;

    my $res = '';
    if ( $args{'title'} ) {
        $res .= "<h1>$args{'title'}</h1>\n";
    }
    $res .= '<table class="sortable">'. "\n";
    $res .= "<thead><tr>". join('', map "<th>$_</th>", @{ $args{'columns'} }) ."</tr></thead>\n";

    foreach my $e ( @{ $args{'elements'} } ) {
        $e = $args{'callback'}->( $e );
    }

    if ( $args{'sort'} ) {
        # ...
    }

    my @totals;

    $res .= "<tbody>\n";

    {
        my @totals = ();
        open my $fh, '>>', \$res;
        foreach my $row ( @{ $args{'elements'} } ) {
            render_table_row( $fh, $row, %args, totals => \@totals );
        }
        close $fh;
        $res .= "</tbody>\n";

        $res .= "<tfoot>\n";
        open $fh, '>>', \$res;
        render_table_row( $fh, \@totals, %args );
        close $fh;
        $res .= "</tfoot>\n";

    }

    $res .= "</table>\n\n";

    print $out $res;
}

sub render_table_row {
    my ($out, $row, %args) = @_;

    my $res = "<tr>";
    foreach my $i ( 0 .. @{ $args{'columns'} }-1 ) {
        unless ( defined $row->[$i] && length $row->[$i] ) {
            $res .= '<td>&nbsp;</td>';
            next;
        }

        my $type = $args{'type'}[$i];
        if ( $type eq 'string' ) {
            $res .= '<td>'. $row->[$i] .'</td>';
        }
        elsif ( $type eq 'percent' ) {
            $res .= sprintf '<td class="number">%0.2f</td>', $row->[$i];
        }
        elsif ( $type eq 'counter' ) {
            $res .= sprintf '<td class="number">%d</td>', $row->[$i];
            $args{'totals'}[$i] += $row->[$i] if $args{'totals'};
        }
        elsif ( $type eq 'num' ) {
            $res .= sprintf '<td class="number">%0.3f</td>', $row->[$i];
            $args{'totals'}[$i] += $row->[$i] if $args{'totals'};
        }
        elsif ( $type eq 'time' ) {
            $res .= sprintf '<td class="number">%0.3f us</td>', $row->[$i]/10;
            $args{'totals'}[$i] += $row->[$i] if $args{'totals'};
        }
        else {
            die "boo: $type";
        }
    }
    $res .= "</tr>\n";

    print $out $res;
}

sub out_context {
    my ($out, $results) = (@_);
    my %total = ();

    my $res = '';

    $res .= "<h1>Context</h1>\n";
    $res .= "<table>\n<tr><th>&nbsp;</th><th>void</th><th>scalar</th><th>array</th></tr>\n";

    foreach my $op ( sort { $a cmp $b } keys %$results ) {
        my $total = 0;
        $total += $_ foreach values %{ $results->{$op} };
        $total{$_} += $results->{$op}{$_} || 0 foreach qw(- $ @);
        
        $res .= "<tr><th>$op</th>";
        foreach my $ctx ( qw(- $ @) ) {
            my $value = $results->{$op}{$ctx};
            $res .= $value
                ? sprintf("<td>%d<sup>%0.2f%%</sup></td>", $value, (100*$value)/$total )
                : "<td>-</td>"
            ;
        }
        $res .= "</tr>\n";
    }

    my $total = 0;
    $total += $_ foreach values %total;
    $res .= "<tr><th>Total:</th>";
    foreach my $ctx ( qw(- $ @) ) {
        $res .= $total{$ctx}
            ? sprintf(
                "<td>%d<sup>%0.2f%%</sup></td>",
                $total{$ctx}, (100*$total{$ctx})/$total
            )
            : "<td>-</td>"
        ;
    }
    $res .= "</tr>\n";
    $res .= "</table>\n";

    print $out $res;
}

sub out_variable_arguments {
    my $out = shift;

    my %stats;
    my %total_per_op;
    my %total_per_len;

    print $out "<h1>Varying arguments</h1>\n";
    walk_report( sub {
        my ($ctx,$lval,$op,$args) = @_;
        return unless rindex($args, '...') >= 0;
        my ($l) = ($args =~ /\.\.\.([0-9]+)/);
        $stats{$op}{$l}++;
        $total_per_len{$l}++;
        $total_per_op{$op}++;
    } );

    my $show_first = 5;

    my $res = '';
    $res .= "<h2>Most used lengths</h2>\n";
    $res .= "<table>\n<tr><th>PP</th>". join( '', map "<th>$_</th>", 1 .. $show_first ) ."</tr>\n";
    foreach my $op ( sort keys %stats ) {
        $res .= "<tr><th>$op</th>";
        my $found = 0;
        foreach my $len (
            sort { $stats{$op}{$b} <=> $stats{$op}{$a} }
            keys %{ $stats{$op} }
        ) {
            $found++;

            $res .= sprintf
                "<td>%d <sup>%0.2f%%</sup></td>",
                $len, (100*$stats{$op}{$len})/$total_per_op{$op},
            ;

            last if $found == $show_first;
        }
        $res .= join '', map "<td>-</td>", 1 .. $show_first-$found
            if $found < $show_first;
        $res .= "</tr>\n";
    }
    {
        my $total = 0;
        $total += $_ foreach values %total_per_len;

        $res .= "<tr><th>Total:</th>";
        my $found = 0;
        foreach my $len (
            sort { $total_per_len{$b} <=> $total_per_len{$a} }
            keys %total_per_len
        ) {
            $found++;

            $res .= sprintf
                "<td>%d <sup>%0.2f%%</sup></td>",
                $len, (100*$total_per_len{$len})/$total,
            ;

            last if $found == $show_first;
        }
        $res .= join '', map "<td>-</td>", 1 .. $show_first-$found
            if $found < $show_first;
        $res .= "</tr>\n";

    }
    $res .= "</table>\n";
    print $out $res;
    $res = '';

    
    my @fractiles = fractiles();
    $res .= "<h2>Fractiles</h2>\n";
    $res .= "<table>\n<tr><th>PP</th>". join( '', map "<th>$_%</th>", @fractiles ) ."</tr>\n";
    foreach my $op ( sort keys %stats ) {
        my $fractiles = calc_fractiles( $stats{$op}, $total_per_op{$op} );
        $res .= "<tr><th>$op</th>";
        foreach my $f ( @fractiles ) {
            $res .= exists $fractiles->{ $f }
                ? sprintf("<td>%0d</td>", $fractiles->{ $f })
                : "<td>-</td>"
            ;
        }
        $res .= "</tr>\n";
    }
    $res .= "</table>\n";
    print $out $res;
    $res = '';
}

sub out_arrays_arguments {
    my $out = shift;

    my %stats;
    my %total_per_len;

    print $out "<h1>Array arguments</h1>\n";

    walk_report( sub {
        my ($ctx,$lval,$op,$args) = @_;
        return unless rindex($args, '@') >= 0;
        my ($prefix, $length, $sufix) = ($args =~ /@\_?\([^\)]+\)([0-9]+)-([0-9]+)-([0-9]+)/);
        next unless defined $prefix;
        $stats{$op}{'prefix'}{$prefix}++;
        $stats{$op}{'length'}{$length}++;
        $stats{$op}{'sufix'}{$sufix}++;
        $total_per_len{'prefix'}{$prefix}++;
        $total_per_len{'length'}{$length}++;
        $total_per_len{'sufix'}{$sufix}++;
    } );

    my $res = '';

    my @fractiles = fractiles();
    $res .= "<h2>Fractiles</h2>\n";
    $res .= "<table>\n<tr><th>PP</th><th></th>". join( '', map "<th>$_%</th>", @fractiles ) ."</tr>\n";
    foreach my $op ( sort keys %stats ) {
        $res .= "<tr><th rowspan='3'>$op</th>";
        foreach my $e ( qw(prefix length sufix) ) {
            $res .= "<tr>" if $e ne 'prefix';
            my $fractiles = calc_fractiles( $stats{$op}{$e} );
            $res .= "<th>$e</th>";
            foreach my $f ( @fractiles ) {
                $res .= exists $fractiles->{ $f }
                    ? sprintf("<td>%0d</td>", $fractiles->{ $f })
                    : "<td>-</td>"
                ;
            }
            $res .= "</tr>\n";
        }
    }
    $res .= "</table>\n";
    print $out $res;
    $res = '';
}

sub fractiles {
    return (100, 99, 98, 97, 96, 95, 90, 80, 70, 60, 50, 30, 10);
}

sub max(@) {
    my $res = 0;
    $res < $_ and $res = $_
        foreach @_;
    return $res;
}

sub calc_fractiles {
    my $data = shift;
    my $total = shift || 0;
    unless ( $total ) {
        $total += $_ foreach values %$data;
    }

    my %copy = %$data;
    use Data::Dumper;

    my @fractiles = fractiles();

    my %res;

    my $sum = 100; my $max = max keys %copy;
    foreach my $v ( sort { $copy{$a} <=> $copy{$b} } keys %copy ) {
        my $portion = (100*$copy{ $v })/$total;
        if ( ($sum - $portion) < $fractiles[0] ) {
            while ( @fractiles && $sum <= $fractiles[0] ) {
                $res{ shift @fractiles } = $max;
            }
            last unless @fractiles;
        }
        $sum -= $portion;
        delete $copy{ $v };
        $max = max keys %copy
            if $max == $v;
    }

    return \%res;
}

# Вывод заголовка HTML-страницы
sub out_head {
    my $out    = shift;
    my $title  = shift;
    my $prefix = shift || '';

    print $out <<"END_HEADER";
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>$title</title>
<link rel="stylesheet" href="${prefix}css/main.css" type="text/css" media="all" />
<script type="text/javascript" src="${prefix}js/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="${prefix}js/jquery.tablesorter.min.js"></script>
<script type="text/javascript" src="${prefix}js/ppap.js"></script>
</head>
<body>
END_HEADER

}

# Вывод футера
sub out_footer {
    my $out = shift;
    print $out "</body></html>\n";
}

# Создание каталога с HTML-отчетом
sub prepare_report_dir {
    foreach my $n (qw(css js)) {
        my $src = File::Spec->catfile( dist_dir('Devel-PPAP'), $n, '*' );
        print "$src\n";
        my $dst = File::Spec->catdir('ppap', $n);
        make_path( $dst, {} );
        copy($_, $dst) foreach glob $src;
    }
}

sub new_file {
    my @path = @_;
    my $name = pop @path;
    my $dir = File::Spec->catfile('ppap', @path);
    make_path($dir);
    open my $fh, '>:utf8', File::Spec->catfile( $dir, $name );
    return $fh;
}

sub report2db {
    my $dbh = create_database();
    import_database();
    create_database_indexes();
    return $dbh;
}

sub import_database {
    my $dbh = create_database();

    my $id = 1;
    my $sth_calls = $dbh->prepare('INSERT INTO calls(id, name, context, lvalue, time) VALUES(?, ?, ?, ?, ?)');
    my $sth_arrays = $dbh->prepare('INSERT INTO arrays VALUES(?, ?, ?, ?, ?, ?)');
    my $sth_varargs = $dbh->prepare('INSERT INTO varargs VALUES(?, ?)');
    walk_report( sub {
        my ($ctx, $lval, $op, $args, $time) = @_;
        $sth_calls->execute($id, $op, $ctx, $lval ? 1 : 0, $time);

        # XXX: multiple arrays in one op?
        if ( $args =~ /\@_?\(0x([0-9a-f]+)\)([0-9]+)-([0-9]+)-([0-9]+)/ ) {
            $sth_arrays->execute( $id, $1, $2, $3, $4, $time );
        }
        if ( $args =~ /\.\.\.([0-9])$/ ) {
            $sth_varargs->execute( $id, $1 );
        }
        $dbh->commit if $id%5000 == 0;
        $id++;
    } );
}

sub create_database_indexes {
    my $dbh = create_database();

    $dbh->do('CREATE INDEX calls1 ON calls(name)');
    $dbh->do('CREATE INDEX arrays1 ON arrays(call)');
    $dbh->do('CREATE INDEX varargs1 ON varargs(call)');
}

{ my $dbh;
sub create_database {
    return $dbh if $dbh;

    require DBI;
    my $name = 'ppap.db';
    { local $@; eval { unlink $name }; }
    $dbh = DBI->connect(
        'dbi:SQLite:'. $name, undef, undef,
        { AutoCommit => 0 }
    ) or die "Couldn't create DB";

    $dbh->do('PRAGMA synchronous = 0');

    $dbh->do( <<END ) or die $dbh->errstr;
CREATE TABLE calls(
    id integer not null,
    name varchar(32) not null,
    context char(1),
    lvalue tinyint not null default 0,
    time int
)
END

    $dbh->do( <<END ) or die $dbh->errstr;
CREATE TABLE arrays(
    call int not null,
    address char(16) not null,
    prefix int not null default 0,
    size   int not null,
    suffix int not null default 0,
    time int
)
END

    $dbh->do( <<END ) or die $dbh->errstr;
CREATE TABLE varargs(
    call int not null,
    size int
)
END
    return $dbh;
} }

BEGIN { $SIG{'INT'} = sub { require Carp; print STDERR Carp::longmess('Killed'); exit 1 }; }

